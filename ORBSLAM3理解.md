Frame：
1）读写该帧对应的相机位姿
2）处理帧和特征点之间的关系，包括判断特征点是否在视野内、获取该帧一定区域内的特征点、特征点校正等
3）恢复深度

KeyFrame：
关键帧之所以存在是因为优化需要，所以KeyFrame的几乎所有内容都是为优化服务的
节点：关键帧的位姿，所以需要有读写位姿的功能；
边：分为两种，第一种边是MapPoint之间的，所以需要有管理MapPoint之间关系的函数，第二种边是和其他关键帧之间的，他们之间需要通过MapPoint产生联系，两帧能够共同观测到一定数量的MapPoint时则可以在他俩之间建立边，这种关系叫共视，所以需要有管理共视关系的函数，这种通过共视关系构建的优化模型叫做Covisibility Graph。通过“生成树（Spanning tree）”来管理各关键帧之间的关系，每个帧都有一个父节点和子节点，节点为其他关键帧，在构建优化模型时，只有具有父子关系的关键帧之间才建立边，换言之，Essential Graph就是Covisibility Graph的子集，这样就大大减少了边的数量，从而起到减小计算量的作用，因此，该类还需要有管理“生成树（Spanning tree）”的函数。

KeyFrame DataBase：
包含一个向量，其中是一个个单词，每个单词对应一个list链表，每个链表是拥有该单词的关键帧。
利用词袋数据，在已有的关键帧中查找和当前帧最接近的帧。
这个功能有两个作用，一是重定位时候，通过检测当前帧和哪个关键帧最接近，来确定相机当前的位置和姿态，对应的检测函数是DetectRelocalizationCandidates。二是在闭环检测时，通过检测来确定当前关键帧需要和哪些关键帧建立闭环修正的边，对应的检测函数是DetectLoopCandidates。 二者的区别不大，唯一的区别是闭环检测时不需要遍历和自己在闭环检测之前就已经有共视关系的关键帧。

MapPoint：
是地图中的特征点，它自身的参数是三维坐标和描述子，在这个类中它需要完成的主要工作有以下方面：
1）维护关键帧之间的共视关系
2）通过计算描述向量之间的距离，在多个关键帧的特征点中找最匹配的特征点
3）在闭环完成修正后，需要根据修正的主帧位姿修正特征点
4）对于非关键帧，也产生MapPoint，只不过是给Tracking功能临时使用

Map：
增删关键帧和地图点

Optimizer：
所有优化的方法都存放在这个类中。优化的目的是调整位姿。先弄清楚有哪些地方需要计算位姿，位姿计算按复杂程度由低到高一共包含以下四种：
1）当前帧位姿计算
2）闭环检测时两帧之间相对位姿计算
3）局部地图关键帧位姿和地图点位置调整
4）全局地图关键帧位姿和地图点位置调整
